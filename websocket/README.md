### 短连接
所谓短连接，及连接只保持在数据传输过程，请求发起，连接建立，数据返回，连接关闭。它适用于一些实时数据请求，配合轮询来进行新旧数据的更替。

### 长连接

长连接便是在连接发起后，在请求关闭连接前客户端与服务端都保持连接，实质是保持这个通 信管道，之后便可以对其进行复用。  
它适用于涉及消息推送，请求频繁的场景（直播，流媒体）。连接建立后，在该连接下的所有请求都可以重用这个长连接管道，避免了频繁了连接请求，提升了效率。

在长连接的应用场景下，`client`端一般不会主动关闭它们之间的连接，`Client`与`server`之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，`server`早晚有扛不住的时候，这时候`server`端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致`server`端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

> `HTTP`作为应用层协议，其实它的生命周期在服务器返回结果时就已经结束了，而所谓的支持长连接，其实是基于'`Keep-Alive`'请求头所约定，从而向下进行长连接发起的一种机制。该长连接依然是基于`TCP`的。


> 因此：所谓`HTTP1.1`及以上支持长连接，并不是`HTTP1.1`可以建立长连接，而是它支持以请求头的方式进行长连接发起（并且要求客户端与服务端都要具备 ‘`Keep-Alive:` `true`’ ）。

### 应用场景

一般长连接（追求实时性高的场景）用于少数`client-end` `to` `server-end`的频繁的通信，例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成`socket`错误，而且频繁的`socket` 创建也是对资源的浪费。  

而像`WEB`网站的`http`服务一般都用短链接（追求资源易回收场景），因为长连接对于服务端来说会耗费一定的资源，而像`WEB`网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。


### 短轮询（Polling）

短轮询的实现思路就是浏览器端每隔几秒钟向服务器端发送 `HTTP` 请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。在服务端响应完成，就会关闭这个 `TCP` 连接，代码实现也最简单，就是利用 `XHR` ， 通过 `setInterval` 定时向后端发送请求，以获取最新的数据

````javascript
setInterval(function() {
  fetch(url).then((res) => {
      // success code
  })
}, 3000);
````
- 优点：实现简单。
- 缺点：会造成数据在一小段时间内不同步和大量无效的请求，安全性差、浪费资源。

 ### 长轮询（Long-Polling）

 客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。大致效果如下：

 ![](http://dev.biubiupiu.cn/20191124090941.png)

 ````javascript
 function async() {
    fetch(url).then((res) => {
    	async();
    	// success code
	}).catch(() => {
		// 超时
        async();
	})
}
````

- 优点：比 `Polling` 做了优化，有较好的时效性。
- 缺点：服务器`hold`住连接会消耗资源，返回数据顺序无保证，难于管理维护

### websocket

#### 通信原理

`WebSocket`复用了`HTTP`的握手通道。具体指的是，客户端通过`HTTP`请求与`WebSocket`服务端协商升级协议。协议升级完成后，后续的数据交换则遵照`WebSocket`的协议。

- 客户端：申请协议升级

![](http://dev.biubiupiu.cn/20191124102119.png)

- 服务端：响应协议升级

![](http://dev.biubiupiu.cn/20191124102241.png)

- Sec-WebSocket-Accept的计算

![](http://dev.biubiupiu.cn/20191124102312.png)


#### 连接保持+心跳

![](http://dev.biubiupiu.cn/20191124102355.png)

#### Sec-WebSocket-Key/Accept的作用

![](http://dev.biubiupiu.cn/20191124102427.png)


#### 总结

通过上面的介绍，大家应该对 `WebSocket` 有了一定认识，其实并不神秘，这里对文章内容简单总结一下。当创建 `WebSocket` 实例的时候，会发一个 `HTTP` 请求，请求报文中有个特殊的字段 `Upgrade` ，然后这个连接会由 `HTTP` 协议转换为 `WebSocket` 协议，这样客户端和服务端建立了全双工通信，通过 `WebSocket` 的 `send` 方法和 `onmessage` 事件就可以通过这条通信连接交换信息。

![](http://dev.biubiupiu.cn/20191124103252.png)

### 补充

为什么`WebSocket`连接可以实现全双工通信而`HTTP`连接不行呢？实际上`HTTP`协议是建立在`TCP`协议之上的，`TCP`协议本身就实现了全双工通信，但是`HTTP`协议的请求－应答机制限制了全双工通信。`WebSocket`连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用`HTTP`协议了，直接互相发数据吧。

安全的`WebSocket`连接机制和`HTTPS`类似。首先，浏览器用`wss://xxx`创建`WebSocket`连接时，会先通过`HTTPS`创建安全的连接，然后，该`HTTPS`连接升级为`WebSocket`连接，底层通信走的仍然是安全的`SSL/TLS`协议。

![](http://dev.biubiupiu.cn/20191124112325.png)


[比较全的链接](https://juejin.im/post/5af557a3f265da0b9265a498)