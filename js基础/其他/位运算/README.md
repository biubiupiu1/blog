[原文](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html)

#### 机器数字和真值

![](http://dev.biubiupiu.cn/20191108091821.png)

#### 原码, 反码, 补码的基础概念和计算方法

![](http://dev.biubiupiu.cn/20191108092758.png)

#### 反码

![](http://dev.biubiupiu.cn/20191108092823.png)

> 反码不改变符号位，即负数的反码还是负数

#### 补码

![](http://dev.biubiupiu.cn/20191108092843.png)

#### 为什么要使用原码, 反码和补码

首先
> 正数的 原码 = 反码 = 补码  
> `[+1] = [00000001]原 = [00000001]反 = [00000001]补`  

>负数的 反码 = ~原码 (除去符号位), 补码 = 反码 + 1  
> `[-1] = [10000001]原 = [11111110]反 = [11111111]补`

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: `1-1 = 1 + (-1) = 0` , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: `1-1=0`

````javascript
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
````

> 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: `1-1=0`

````javascript
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
````

> 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

````javascript
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
````

> 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

````javascript
(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
````

`-1-127`的结果应该是`-128`, 在用补码运算的结果中, `[1000 0000]`补 就是`-128`. 但是注意因为实际上是使用以前的-0的补码来表示`-128`, 所以`-128`并没有原码和反码表示.(对`-128`的补码表示`[1000 0000]`补算出来的原码是`[0000 0000]`原, 这是不正确的)

使用补码, 不仅仅修复了`0`的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么`8`位二进制, 使用原码或反码表示的范围为`[-127, +127]`, 而使用补码表示的范围为`[-128, 127]`.

> 因为机器使用补码, 所以对于编程中常用到的`32`位`int`类型, 可以表示范围是: `[-2^31, 2^31-1]` 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值

#### &按位与

对每一个比特位执行与（`AND`）操作

常用技巧：
- `x & 0 = 0`
- `x & -1 = x`
- `(n & 1) === 0   //true 为偶数，false 为奇数。`

#### |按位或

对每一个比特位执行与（`OR`）操作

常用技巧
- `x | -1 = -1`
- `x | 0 = x`;`
- `x | 0 = x`

#### ~取反

对每一个比特位执行非（`NOT`）操作

常用技巧
- `~x = -(x + 1)`
- `~~x = x`

#### ^按位异或

对每一对比特位执行异或（XOR）操作。当 a 和 b 不相同时，a ^ b 的结果为 1。

特性
- a ^ a = 0
- 两个数异或，值为不进位相加

常用件技巧
- `x^0 = x`
- `x^-1 = ~x`

#### <<左移运算

它把数字中的所有数位向左移动指定的数量，向左被移出的位被丢弃，右侧用 0 补充

`2 << 5 = 64`
`-2 << 5 = -64`

![](http://dev.biubiupiu.cn/20191108175944.png)

常用技巧
- `x << n = x * 2^x`(这里^的意思是指数)
- `x << 0 = x`

#### >>有符号右移运算
该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。

左边空出的位用0或者1填补。正数用0填补，负数用1填补

常见技巧
- `x<<n === x/2ⁿ`
- `(x>>0)===x`


![](http://dev.biubiupiu.cn/20191108180016.png)

#### >>>无符号右移运算

该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）

对于非负数，有符号右移和无符号右移总是返回相同的结果。例如 `9 >>> 2` 和 `9 >> 2` 一样返回 `2`：

但是对于负数却不尽相同。 `-9 >>> 2` 产生 `1073741821` 这和 `-9 >> 2` 不同：

````javascript
-9 (base 10): 11111111111111111111111111110111 (base 2)
-9 >>> 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)
````

#### 注意
- 求反码的时候符号位不变
- 进行位运算，取正数的源码，负数的补码进行运算，当结果符号位1时还需要对结果进行求补码

#### 总结

- 所有的位运算都可以对小数取底
- 对于按位与`&`，可以用 `(n & 1) === 0 //true` 为偶数，`false` 为奇数。来判断奇偶。用`x&-1===Math.floor(x)`来向下取底。
- 对于按位或`|`，可以用`x|0===Math.floor(x)`来向下取底。
- 对于取反运算`~`，可以用`~~x===Math.floor(x)`来向下取底。
- 对于异或运算`^`，可以用`(x^0)===Math.floor(x)`来向下取底。
- 对于左移运算`<<`，可以`x<<n === x*2ⁿ`来求2的n次方，用`x<<0===Math.floor(x)`来向下取底
- 对于有符号右移运算`>>`，可以`x<<n === x/2ⁿ`求一个数字的 N 等分，用`x>>0===Math.floor(x)`来向下取底。
- 对于无符号右移运算`>>>`，可以`(n === (n >>> 0)) ? true : false;`来判断数字正负，用`x>>>0===Math.floor(x)`来向下取底。

