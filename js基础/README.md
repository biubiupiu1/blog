## eval 是做什么的？

eval 的功能是把对应的字符串解析成 JS 代码并运行

+ eval不安全，若有用户输入会有被攻击风险
+ 非常耗性能（先解析成 js 语句，再执行）

## 严格模式的限制

![](http://dev.biubiupiu.cn/20191130170209.png)

+ 严格模式通过抛出错误来消除了一些原有静默错误。
+ 严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
+ 严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。

## Javascript 垃圾回收方法

**标记清除（mark and sweep）**

+ 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
+ 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了

**引用计数(reference counting)**

+ 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间

> 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

## 哪些操作会造成内存泄漏？

+ 意外的全局变量
+ console.log
+ 闭包
+ DOM泄露(removeClild, 但是并没有取消对dom对象的引用)
+ 子元素存在引用
  ![](http://dev.biubiupiu.cn/20191130174737.png)

## 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？

模块化可以给我们带来以下好处

+ 解决命名冲突
+ 提供复用性
+ 提高代码可维护性

实现模块化方式：

+ 立即执行函数
+ AMD 和 CMD
+ CommonJS(Node)
+ ES Module

## cookie，localStorage，sessionStorage，indexDB

![](http://dev.biubiupiu.cn/20191130175232.png)