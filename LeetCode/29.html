<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /**
        29题（这里有问题，可以改为负数求解，因为正数转负数会出现-2^31 变成 2^31次方，这样就溢出了）
        给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
        返回被除数 dividend 除以除数 divisor 得到的商。
         * @param {number} dividend
         * @param {number} divisor
         * @return {number}
         */
        var divide = function (dividend, divisor) {

            let count = 0;

            let flag = (dividend >= 0 && divisor >= 0) || (dividend < 0 && divisor < 0);

            dividend = Math.abs(dividend);
            divisor = Math.abs(divisor);

            let tempDivsor = divisor;

            if (dividend === divisor)
                return flag ? 1 : -1

            while (tempDivsor <= dividend) {
                let tempCount = 1;
                while (tempDivsor > 0 && tempDivsor <= dividend) {
                    dividend -= tempDivsor;
                    count += tempCount;
                    tempDivsor <<= 1;
                    tempCount <<= 1;
                }
                tempDivsor = divisor;
            }

            let res = flag ? count : 0 - count;
            res = res > Math.pow(2, 31) - 1 ? Math.pow(2, 31) - 1 : res;

            return res;
        };

        console.log(divide(-2147483648, -1))


        /**
         * @param {string} s
         * @param {string[]} words
         * @return {number[]}
         */
        var findSubstring = function (s, words) {

            if (!words.length)
                return [];

            let oMap = {};
            words.forEach(item => oMap[item] = (oMap[item] ? oMap[item] + 1 : 1));

            let iLen = words[0].length;
            let strLen = words.length * iLen

            let res = [];

            for (let i = 0; i <= s.length - strLen; i++) {
                let subStr = s.slice(i, i + strLen);
                let tMap = {};
                let j = 0;
                for (; j <= strLen - iLen; j += iLen) {
                    let str = subStr.slice(j, j + iLen);
                    if (oMap[str]) {
                        tMap[str] = tMap[str] ? tMap[str] + 1 : 1
                    } else {
                        break;
                    }
                    if (tMap[str] > oMap[str])
                        break
                }
                if (j > strLen - iLen) {
                    res.push(i);
                }
            }

            return res;
        };

        console.log(findSubstring("wordgoodgoodgoodbestword", ["word", "good", "best", "good"]))


        /**
         * @param {number[]} nums
         * @return {void} Do not return anything, modify nums in-place instead.
         下一个最小排列
         */
        var nextPermutation = function (nums) {
            let len = nums.length;

            for (let i = len - 1; i > 0; i--) {
                if (nums[i] > nums[i - 1]) {
                    let minIndex = i;
                    for (let j = i; j < len; j++) {
                        if (nums[j] > nums[i - 1] && nums[j] <= nums[i]) {
                            minIndex = j;
                        }
                    }
                    [nums[i - 1], nums[minIndex]] = [nums[minIndex], nums[i - 1]]
                    let l = i; h = len - 1;
                    /* 倒置数组 */
                    while (l < h) {
                        [nums[l], nums[h]] = [nums[h], nums[l]]
                        l++;
                        h--;
                    }
                    return
                }
            }
            let l = 0; h = len - 1;
            while (l < h) {
                [nums[l], nums[h]] = [nums[h], nums[l]]
                l++;
                h--;
            }
        };
        let arr = [2, 3, 1, 3, 3]
        nextPermutation(arr)
        console.log(arr);



        /**
         * @param {string} s
         * @return {number}
        这里不需要这样遍历，只需要从左到右遍历一遍，再从右到左遍历一遍就可以了
         */
        var longestValidParentheses = function (s) {
            let len = s.length;

            let max = 0;

            for (let i = 0; i < len - 1; i++) {
                let num = 0;
                let left = 0;
                let right = 0;
                for (let j = i; j < len; j++) {
                    if (s[j] === "(") {
                        left++;
                    } else {
                        if (right + 1 > left) {
                            break;
                        }
                        right++;
                    }
                    num++;
                    if (left === right) {
                        i = j + 1;
                        max = Math.max(max, num)
                    }
                }
            }

            return max;
        };
        console.log(longestValidParentheses(")(((((()())()()))()(()))("))

        /**
         * @param {string} s
         * @return {number}
         动态规划
         */
        var longestValidParentheses2 = function (s) {
            let len = s.length;

            let max = 0;

            let dp = new Array(len);
            dp[0] = 0;
            for (let i = 0; i < len; i++) {
                if (s[i] === "(") {
                    dp[i] = 0;
                } else {
                    if (s[i - 1] === "(") {
                        dp[i] = (dp[i - 2] || 0) + 2;
                    } else if (s[i - 1] === ")") {
                        if (s[i - 1 - dp[i - 1]] === "(") {
                            dp[i] = (dp[i - 1 - dp[i - 1] - 1] | 0) + dp[i - 1] + 2
                        } else {
                            dp[i] = 0;
                        }
                    } else {
                        dp[i] = 0;
                    }
                }
            }
            return Math.max(...dp);
        };
        console.log(longestValidParentheses2(")()())"))

        /**
         * @param {number[]} nums
         * @param {number} target
         * @return {number}
         假设按照升序排序的数组在预先未知的某个点上进行了旋转。
        ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
        搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
        你可以假设数组中不存在重复的元素。
        你的算法时间复杂度必须是 O(log n) 级别。

        异或精髓

        二分的时候，不知道该往右规约还是往左，可以只研究一边，然后剩下的就是其他规约了

         */
        var search = function (nums, target) {
            let len = nums.length;
            let left = 0;
            let right = len - 1;

            while (left <= right) {
                let mid = Math.floor((left + right) / 2);
                if (target === nums[mid]) {
                    return mid;
                } else if ((target < nums[mid]) ^ (nums[mid] < nums[left]) ^ (nums[left] <= target)) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return -1;
        };

        console.log(search([5, 1, 3], 3))
    </script>
</body>

</html>